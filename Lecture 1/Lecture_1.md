# Лекция 1

Темы, которые будут рассмотрены в этой лекции:

- Ссылки;
- дружественные функции;
- конструкторы копии;
- ключевое слово this;
- перегрузка операторов;
- шаблоны;
- исключения;
- перегрузка операторов new и delete;
- STL.

## Ссылки

Ссылки можно использовать в C++ вне зависимости от передачи аргументов функциям. Такие ссылки называются независимыми. Необходимо присвоить независимой ссылке значение при ее инициализации. Таким образом, ссылка должна указывать на уже существующий объект или переменную. С использованием ссылок связаны некоторые ограничения:

- Нельзя ссылаться на ссылку;
- нет возмможности создавать массивы из ссылок;
- нельзя создать указатель на ссылку;
- ссылки нельзя использовать для доступа к битовым полям структур.

В общем и целом, ссылки были предусмотрены при создании языка C++ в основном для передачи параметров функциям по ссылкам, поэтому применение этого механизма вне этого контекста достаточно ограниченно.

## Дружественные функции

Дружественные функции - это механизм языка C++, позовляющий предоставлять доступ к закрытым членам класса функциям, которые не являются членами этого класса. Для использования дружественной функции необходимо ее объявить в классе:

```C++
class Plane {
    // ...
public:
    friend void fly(Plane);
    // ...
};
```

Затем необходимо просто определить дружественную функцию:

```C++
void fly(Plane pl) {
    pl.x += 100;
}
```

Функция может быть "другом" нескольких классов. При этом вызов этой функции осуществляется без применения оператора "точка". Дружественные функции могут быть полезны для перегрузки некоторых опраторов (об этом ниже), написания функций ввода-вывода, либо для предоставления определенного доступа, в случае, если два и более класса имеют в себе члены, свзяанные с другими частями программы, и вы хотите предоставить единый интерфейс доступа к ним.

Дружественная функция одного класса может при этом быть функцией-членом другого.

## Конструкторы копии

Конструктор копии вызывается при инциализации одного объекта другим и управляет процессами, происходящими при создании копии исходного объекта.

Конструкторы копии могут вызываться в трех случаях:

- один объект инициализирует другой явным образом (как, например, при оъявлении);
- при вызове функции, в случае, если аргумент передается "по значению", то будет передана его копия;
- в случаее, если функция возвращает объект, то на самом деле данный объект будет временным, и при присваивании значения, возвращаемого функцией, какой-либо переменной, будет вызван конструктор копии.

Для определения конструктора копии не обходимо сначала объявить в классе конструктор, принимающий в качестве аргумента экземпляр класса, а затем уже определить данный конструктор. Вообще конструкторы копии необходимы для того, чтобы избежать побочных эффектов создания побитовой копии (например, если класс в качестве свойства содержит укахатель, при побитовом копировании объекта этот указатель будет скопирован, в то время, как при копировании вам может потребоваться выделение нового участка памяти с заполнением его копией того объекта, на который был указатель в оригинале).

## Ключевое слово this

this - указатель на объект, который вызывает функцию-член. Таким образом, при определении какого-либо метода мы можем обратиться к любому члену объекта, который его вызвал при помощи ключевого слова this. На самом деле, если в текущем пространстве имен имя этого члена не переопределялось, то мы все равно можем к нему обратиться просто по его идентификатору. Но, в случае, когда этот идентификатор был переопределен используется ключевое слово this:

```C++
class Student {
private:
    char name[32];
public:
    void put_name(char name[32]);
    // ...
};
// ...
void Student::put_name(char name[32]) {
    memcpy(this.name, name, 32);
}
```

## Перегрузка операторов

Перегрузка операторов позволяет переопределить поведение стандартных операторов. Например, оператор "+" для чисел имеет смысл воспринимать как "сложение", а для строк, скорее как "конкатенацию". Именно при помощи перегрузки операторов вы можете сами определить поведение стандартных операторов в отношении экземпляров ваших классов.

Перегрузка операторов может выполняться как при помощи функций-членов класса, так и при помощи функций, которые членами класса не являются.

Сама перегрузка выполняется при помощи ключевого слова operator.

### Перегрузка операторов при помощи функций-членов класса

Рассмотрим перегрузку оператора сложения при помощи функции-члена класса в контексте применения к задачи с трехмерными координатами:

```C++

class Point {
private:
    int x, y, z;
public:
    Point(x, y, z) { this.x = x; this.y = y; this.z = z; }
    Point() { x = 0; y = 0; z = 0; }
    Point operator+(Point op2);
};

Point Point::operator+(Point op2) {
    Point temp;

    temp.x = x + op2.x;
    temp.y = y + op2.y;
    temp.z = z + op2.z;

    return temp;
}
```

Несмотря на то, что оператор "+" является бинарным, явным образом ему передается только правый операнд, а левым в свою очередь является тот объект, от которого и будет вызвана соответствующая функция-член. Имено пооэтому при перегрузке бинарного оператора с использованием функция члена, явно передается только один аргумент. При этом, как мы уже знаем, первый операнд будет доступен при помощи ключевого слова this.

При определении унарных операторов аргумент функции-члену не передается вообще. Следует помнить, что при помощи конструкции operator++ будет перегружаться префиксная форма оператора "++". Для перегрузки постфиксной формы необходимо добавить аргумент функции типа int, который при этом не будет использоваться (это как раз и не обходимо, чтобы была возможность определить, какой именно оператор мы перегружаем, в зависимости от сигнатуры функции).

```C++
class Point {
private:
    int x, y, z;
public:
    // ...
    Point operator++(); // префиксная форма
    Point operator++(int unused); // постфиксная форма
};

// ...

```

Общий совет при перегрузке операторв: не использовать их для сокращения кода, а использовать для повышения читаемости. Если в конексте ваших классов операция "умножения" будет иметь определенный смысл (как для матриц, например), то есть смысл перееопределить оператор *. Невозможно перегружать операторы:

- .
- ::
- .*
- ?

### Перегрузка операторов с использованием функций, не являющихся членами класса

Для перегрузки операторов возможно использовать дружественные функции:

```C++
class Point {
private:
    int x, y, z;
public:
    Point(x, y, z) { this.x = x; this.y = y; this.z = z; }
    Point() { x = 0; y = 0; z = 0; }
    friend Point operator+(Point op1, Point op2);
};

Point operator+(Point op1, Point op2) {
    Point temp;

    temp.x = op1.x + op2.x;
    temp.y = op1.y + op2.y;
    temp.z = op1.z + op2.z;

    return temp;
}
```

Аналогично с перегрузкой унарных операторов:

```C++
class Point {
private:
    int x, y, z;
public:
    Point(x, y, z) { this.x = x; this.y = y; this.z = z; }
    Point() { x = 0; y = 0; z = 0; }
    friend Point operator++(Point op1);
};

Point operator++(Point op1) {

    op1.x++;
    op1.y++;
    op1.z++;

    return op1;
}
```

Операторы [] и () также возможно перегружать. Таким образом, например, можно придать собственный смысл операциям взятия индекса.

## Шаблоны

Шаблоны призваны облегчить создание одного и того же кода, который используется многократно. Шаблоны используются при определении обобщенных функций и обобщенных классов. Обобщенные функции - функции, перегружающие сами себя.

### Шаблонные функции

Определение обобщенной функции начинается с ключевого слова template:

```C++
template <class Ttype> type func_name(args_list) {
    // тело функции
}
```

Ttype - своего рода "заполнитель" для типа данных, которые будут обрабатываться функцией. Его можно использовать в теле функции. Вместо него компилятор автоматически подставит имя нужного класса. Несмотря на то, что для объявления обобщенной функции используется ключевое слово class, возможно и использование ключевого слова typename.

Вот пример обобщенной функции, которая меняет местами свои аргументы:

```C++
template <class X> void swapargs(X &a, X &b) {
    X temp;
    temp = a; // помните, что здесь будет вызван конструктор копии
    a = b; // и здесь
    b = temp; // тут тоже
}
```

Естественно, можно создать обобщенную функцию, которая имеет два и более обобщенных типов:

```C++
template <class type1, class type2> type func_name(args_list) {
    // тело функции
}
```

Создавая обобщенную функцию в действительности мы даем возможность компилятору перегрузить столько версий функции, сколько понадобится в ходе выполнения.

Для определенного рода специализации нашей обобщенной функции, можно перегрузить ее явно. Например, можно оптимизировать по памяти нашу функцию swapargs для аргументов типа int:

```C++
void swapargs(int &a, int &b) {
    a += b;
    b = a - b;
    a -= b;
}
```

Тогда при вызове функции swapargs от аргументов типа int будет вызвана специализированная функция.

Также существует альтернативный синтаксис для явного переопределения обобщенной функции:

```C++
template<> void swapargs<int>(int &a, int &b) {
    a += b;
    b = a - b;
    a -= b;
}

Ключевое слово template<> указывает на перегурзку шаблонизированной функции, а <int> - на то, что это int-версия функции. Этот синтаксис является рекомендуемым, так как более явно указывает на специализированную функцию и то, какую версию это функции мы определяем.

Стоит отметить, что если вы находитесь в ситуации, когда одна функция для разных типов реализует разное поведение, то возможно следует использовать перегурженные функции, вместо обобщенных с их дальнейшей специализацией.

Естественно, что и сами шаблоны функций можно перегружать:

```C++
template <class Type1> void f(Type1 x) { 
    //.. 
}
template <class Type1, class Type2> void f(Type1 x, Type2 y) { 
    //.. 
}
```

### Шаблонные классы

Естественно, что нам может понадобиться класс, членом которого могут являться данные и функции различных типов. Тогда используется следующая конструкция:

```C++
template <class Ttype> class Class_name {
    // ...
    // в теле класса обращение к Ttype приведет к обрашению к той версии класса, которая работает
    // с данным типом
    // ...
}
```

Также можно создавать шаблоны с несколькими типами.

## Исключения

Обработка исключений - инструмент, позволяющий обрабатывать ошибки времени выполнения.

Инструкция throw предназначена для возбуждения исключений, а try ... catch для их обработки:

```C++
try {
    // блок кода, в котором потенциально может возникнуть исключение
}
catch (type1 arg) {
    // обработка исключения типа type1
}
catch (type2 arg) {
    // обработка исключения типа type2
}
// ...
```

Следует брать во внимание, что обработчик базовога класса среагирует и на исключение производного класа. Таким образом, если у нас есть два класса исключений ValueError и NonPositiveValueError, которые мы определили для реализации нашей функции логарифма, при этом NonPositiveValueError - наследник класса ValueError, то catch инструкция для ValueError обработает и NonPositiveValueError, в ситуации, если либо не существует обработчика исключений класса NonPositiveValueError, либо этот блок стоит позже catch-блок для обработки ValueError.

Для перехвата всех исключений используется специальный вид catch-блока:

```C++
catch (...) {
    // обработка всех исключений, необработанных ранее
}
```

То какие типы исключений разрешено гененрировать функции можно определить следующим образом:

```C++
type func_name(args_list) throw(types_list)
```

Где types_list - список имен типов исключений, которые могут возбуждаться при работе функции. Имена типов разделяются запятыми. Если функция вообще не должна возбуждать исключения, оставьте этот список пустым. При возбуждении исключения, тип которого не предусмотрен блоком throw данной функции будет выполнена функция unexpected(), которая при стандартном поведении вызывает функцию abort(), т.е. аварийное завершение программы, не возвращающее никакого значения в выполняющую среду.

Данные ограничения действуют только на исключения, которые будут обработаны вне функции. Таким образом, даже если исключения данного типа нет в блоке throw, оно все равно может быть возбуждено в теле функции, в случае, если в самой функции есть try ... catch блок, обрабатывающий исключения этого типа.

Внутри catch-блока возможно повтора возбудить исключение, тогда оно будет обработано catch-блоком, стоящим выше по иерархии. Для этого просто используется конструкция `throw ;`. Исключение, которое обрабатывалось catch-блоком будет возбуждено заново.

Оператор new возбуждает исключение типа bad_alloc и его можно обрабатывать при помощи конструкции try ... catch. также есть специальная версия оператора new, которая не возбуждает исключений, а возвращает null в случае неудавшейся попытки выделения памяти. Вызывается как new(nothrow).

## Перегрузка операторов new и delete

Для перегрузки операторов new и delete а также nothrow версий для какого-то отдельного класса необходимо сделать целевые функции членами этого класса:

```C++
class Student {
// ...
public:
    void *operator new ();
    void *operator new[] (size_t size);
    void operator delete (void *p);
    void operator delete[] (void *p);
    void *operator new (const nothrow_t &n);
    void *operator new[] (size_t size, const nothrow_t &n);
    void operator delete (void *p, const nothrow_t &n);
    void operator delete[] (void *p, const nothrow_t &n);

}
``` 

## STL

STL - Standart Template Library (стандартная библиотека шаблонов) - набор шаблонных классов и функций общего назначения. Есть три типа основных элементов STL: контейнеры, алгоримы и итераторы. Контейнеры - классы, содержащие други классы (например, векторы). Алгоритмы служат для обработки содержания контейнеров, а итераторы имеют некоторое подобие указателям и служат для последовательного опроса содержимого контейнера.

| Итератор | Описание |
| :---------: |:-------:|
| random access   | Сохраняют и считывают значения. Обеспечивают произвольный доступ к содержимому контейнера       |
| bidirectional | Сохраняют и считывают значения. Обеспечивают декрементно-инкрементный проход по содержимому |
| forward | Сохраняют и считывают значения. Обеспечивают инкрементный проход по содержимому |
| input | Считывают значения. Обеспечивают инкрементное перемещение |
| output | Записывают значения. Обеспечивают инкрементное перемешение |

## Домашнее задание

Г. Шилдт "C++. Базовый курс" до конца.
Assigments.pdf задания из 2-го раздела.