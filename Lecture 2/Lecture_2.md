# Лекция 2

Темы, которые будут рассмотрены в этой лекции:

- STL;
- контейнеры;
- итераторы;
- векторы;
- списки;
- отображения;
- алгоритмы;
- класс String.

## STL

STL - Standart Template Library (стандартная библиотека шаблонов) - набор шаблонных классов и функций общего назначения. Есть три типа основных элементов STL: контейнеры, алгоримы и итераторы. Контейнеры - классы, содержащие други классы (например, векторы). Алгоритмы служат для обработки содержания контейнеров, а итераторы имеют некоторое подобие указателям и служат для последовательного опроса содержимого контейнера.

## Контейнеры

Контейнеры - это объекты, предназначенные для хранения других объектов. Контейнерные классы STL перечислены в таблице ниже. Класс String будет рассмотрен в лекции позднее.

| Контейнер | Описание | Заголовок |
|: ------- :|: ------ :|: ------- :|
| vector | Динамический массив | vector |
| queue | Очередь | queue |
| priority_queue | Очередь с приоритетами | queue |
| stack | Стек | stack |
| deque | Дек (очередь с двусторонним доступом) | deque |
| list | Линейный список | list |
| map | Отображение, множество пар "ключ-значение" | map |
| multimap | Мультиотображение, один ключ может быть связан сразу со множеством значений | map |
| set | Множество | set |
| multiset | Мультимножество | set |
| bitset | Битовое множество | bitset |

Поскольку внутри контейнеров используются произвольные типы, для обеспечения возможности доступа к этим типам вне зависимости от реализации контейнера в них определны специальные typedef-имена. Вот некоторые из них:

| Тип | Описание |
|: - :|: ------ :|
| size_type | Размерный тип, используется вместо size_t |
| reference | Ссылочный тип |
| const_reference | Постоянная ссылка |
| iterator | Итератор |
| const_iterator | Постоянный итератор |
| reverse_iterator | Реверсивный итератор |
| const_reverse_iterator | Постоянный реверсивный итератор |
| value_type | Тип элементов контейнера |
| allocator_type | Тип распределителя памяти |
| key_type | Тип ключа |
| key_compare | Тип функции сравнения ключей |
| mapped_type | Тип значения отображения ("значение" в паре "ключ-значение") |
| value_compare | Тип функции, которая сравнивает два значения |

Рассмотрим контейнеры vector, list и map. Почему их? Во-первых, они одни из основных, а во-вторых, именно они подробно разобраны в той к книжке, из которой я это списываю :)

## Векторы

Векторы - это динамические массивы. Векторы обеспечивают дополнительное выделение памяти по мере необходимости. При этом, как и при работе с обычными массивами в C++ вы можете получать значение внутри вектора по его индексу при помощи оператора индексации. Рассмотрим конструкторы класса Vector:

```C++
explicit vector(const Allocator &a = Allocator());
explicit vector(size_type num, const T &val = T(),
				const Allocator &a = Alllocator());
vector(const vector <T, Allocator> &ob);
template <class InIter> vector(InIter start,
							   InIter end,
                               const Allocator &a = Allocator ())
```

Первая форма создает пустой вектор, вторая вектор заданной длины, причем есть возможность указать значение по умолчанию, третья форма создает вектор с теми же значениями, что и ob, а четвертая для создания вектора со значениями в некотором диапазоне.

Для использования собственного типа в векторе следует определить конструктор по умолчанию и операторы сравнения "меньше" и "равно". Кроме того в конкретной реализации может понадобиться определение других операторов, информацию на этот счет можно найти в документации к вашему компилятору.

[Подробности](http://ru.cppreference.com/w/cpp/container/vector)

### Доступ к содержимому вектора с помощью итератора

```C++
#include <iostream>
#include <vector>

int main() {
	vecotr<char> v;
	int i;
	for(i = 0; i < 10; i++) v.push_back('A' + i);
	for(p = v.begin(); p != v.end(); v++) {
		std::cout << *p << " ";
	}
}
```

### Вставка и удаление элементов из вектора

```C++
#include <iostream>
#include <vector>

int main() {
	vector<char> v;
	unsigned int i;
	
	for(i=0; i<10; i++) v.push_back('A' + i);
	std::cout << "Size: " << v.size << std::endl;
	for(i=0; i<v.size(); i++) {
		std::cout << v[i] << " ";
	}
	std::cout << std::endl;
	
	vector<char>::iterator p = v.begin();
	p += 2;
	v.insert(p, 10, 'X'); // 10 символов 'X' будут вставлены в позиции с 3 по 12
	for(i=0; i<v.size(); i++) {
		std::cout << v[i] << " ";
	}
	std::cout << std::endl;
	p = v.begin();
	p += 2;
	v.erase(p, p+10); // будут удалены 10 символов
	for(i=0; i<v.size(); i++) {
		std::cout << v[i] << " ";
	}
	std::cout << std::endl;
	return 0;
}
```

## Списки

Список - это контейтер с двунаправленным доступом к своим элементам.

В классе list определены следующие конструкторы:

```C++
explicit list(const Allocator &a = Allocator() );
explicit list(size_type num, const T &val = T (),
			  const Allocator &a = Allocator());
list(const list<T, Allocator> &ob);
template <class InIter>list(InIter start,
                            InIter end,
							const Allocator &a = Allocator());
```

Первый конструктор создает пустой список, второй - создает список с num элементов со значением T, третий - создает список, который содержит те же элементы, что и объект ob, а четвертый используется для создания списка со значениями в диапозоне от start до end.

http://ru.cppreference.com/w/cpp/container/list

## Отображения

Отображения - это множества пар ключ-значение.

Для класса map определены следующие конструкторы:

```C++
explicit map(const Comp &cmpfn = Comp(),
			 const Allocator &a = Allocator());
map(const map<Key, T, Comp, Allocator> &ob);
template <class InIter> map(InIter start,
							InIter end,
							const Comp &cmpfn = Comp(),
							const Allocator &a = Alllocator());
```

Первый конструктор создает пустое отображение, второй создает отображение, содержащее  те же элементы, что и ob, третий создает отоброжение, которое содержит элементы в диапазоне от start до end)

Пары ключ-значение хранятся в отображениях как объекты класса pair.

[Подробности](http://ru.cppreference.com/w/cpp/container/map)

## Алгоритмы

В STL существует достаточно мощный инструмент - алгоритмы. Для их использования нужно подключить заголовок algorithm. Алгоритмы реализуют более сложное поведение, чем функции-члены соответствующих контейнеров. Все алгоритмы являются шаблонными функциями. Это означает, что любой алгоритм может быть применен к любому контейнеру.

[Подробности](http://ru.cppreference.com/w/cpp/algorithm)

## Строки

В C++ строки можно рассматривать либо как сроки в смысле C (массивы элементов типа char с обязательным завершающим нулем), либо как объекты класса string. Для использования последних необходимо подключить заголовок string.

Помните функции библиотеки string.h? Это был достаточно неудобный инструмент, поскольку требовал вызова библиотечной функции для, скажем сравнения строк. Поскольку инструменты C++ позволяют переоппределять поведение операторов, то в отношении объектов класса string сравнение делается просто при помощи операторов сравнения. То же можно сказать и про опреаторы присвоения, операцию конкатенации, которая теперь выражена оператором сложения и т.д.

[Подробности](http://ru.cppreference.com/w/cpp/string/basic_string)

Если все же вы оказались в ситуации, где необходимо получить из объекта класса string строку в смысле C, воспользуйтесь функцией-членом c_str().

## Практика

Здесь будет практика, решенная на лекции
