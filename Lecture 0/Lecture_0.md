# Лекция 0

Темы, которые будут рассмотрены в этой лекции:

- Вступление;
- пространства имен;
- классы и объекты;
- основные принципы ООП: инкапсуляция, полиморфизм, наследование;
- перегрузка функций;
- передача аргументов по ссылке;
- задание аргументов по умолчанию;
- дополнительно: передача аргументов функции main.

## Вступление

В данном курсе лекций, посвященном языку C++, мы будем рассматривать данный язык как расширение C. Таким образом, предполагается, что слушатели уже знакомы с синтаксисом языка C, основными принципами императивного программирования и инструментами разработки. Если вам необходимо освежить знания в памяти, то можно обратиться к [лекций по C](https://github.com/devsagul/C). Рекомендации касательно набора инструментов не изменились, для компиляции все также следует использовать GNU Compiler Collection, а для написания программ — наиболее удобный для вас текстовый редактор. Также возможно использовать IDE вместо всего комплекса инструментов. Более подробно эти вопросы обсуждены в [этой](https://github.com/devsagul/C/blob/master/Lecture%200/lecture_0.md) лекции из курса по языку программирования С.

Основным отличием языка C++ от языка C является наличие **объектно-ориентированной парадигмы**. Но это не единственное нововведение. Некоторые из "новинок" языка C++ настолько понравились разработчикам новых стандартов языка C, что в последствии они стали его частью (например, перегрузка функций).

C++ предоставляет разработчику право выбора, использовать ООП или нет, но в большинстве случаев, если вы не пользуетесь преимуществами ООП, возможно, стоит рассмотреть переход на C.

## Пространства имен

Пространства имен — инструмент направленный на разрешение конфликта имен. Еслы вы вводите собственное пространство имен, то любое имя, введеное в нем будет доступно только из него. Для того, чтобы использовать это имя извне, необходимо будет явно указать пространство имен перед использованием его, например:

```C++
std::cout << "Hello, world!\n";
```

Либо подключить пространство имен в блоке, в котором оно будет использоваться при помощи using namespace:

```C++
using namespace std;
cout << "Hello, world!\n";
```

Для того, чтобы сделать видимым конкретный идентифекатор в каком-то пространстве имен используется следующая конструкция:

```C++
using std::cout;
cout << "Hello, world!\n";
```

Для определения собственного пространства имен используется ключевое слово namespace:

```C++
namespace name {
	// объявления
}
```

Стоит отметить, что пространства имен должны объявляться вне любых других областей видимости, т.е. не могут быть вложены в функции, но при этом допускается определять одно пространство имен внутри другого.

Разделение объявлений в пространстве имен не является ошибкой:

```C++
namespace name {
	// объявления
}
//
// гипотетический код программы
//
namespace name {
	// еще объявления
}
```

Также возможно определение анонимного пространства имен для ограничения доступа к переменным извне:

```C++
namespace {
	// объявления
}
```

## Классы и объекты

Для ООП основными являются понятия *класса* и *объекта*. Проводя аналогии с императивным программированием, класс представляет собой некоторую форму, шаблон, по которому будут строиться объекты. Последние, в свою очередь, похожи на переменные особого типа, который и определеяется классом.

Внутри класа могут быть определены переменные и функции. Подобные переменные называются *членами данных* (более распространенное, но, строго говоря, неверное по отношению к C++, название — *свойства*), а функции — функциями-членами (опять же, часто можно услышать слово *методы* в отношении подобных функций).

Члены класса в С++ могут быть *закрытыми*, *защищенными* и *открытыми*, вне зависимости от того, идет ли речь о члене данных или о функции-члене. Закрытые члены доступны только внутри класса (исключение составляют "дружественные" функции), защищенные также доступны лишь изнутри, но могут быть вызваны потомком в зависимости от доступа наследования, а открытые доступны вне класса.

Для объявления класса используется ключевое слово класс:

```C++
class Student {
	private:
		char name[32];
		char surname[32];
		unsigned short course;
		float avg_grade;
	public:
		void say_name();
		float get_avg_grade();
} ;
```

В примере выше представлен пример объявления класса Student. Членами данных являются два массива символов name и surname, номер курса unsigned short course, и число с плавающей запятой avg_grade. Все члены данных являются закрытыми. Также опеределены две открытые функции-члены: say_name и get_avg_grade. Давайте определим их:

```C++
void Student::say_name() {
	std::cout << "Меня зовут " << name << " " << surname << "!\n";
}
float Student::get_avg_grade() {
	return avg_grade;
}
```

Как мы видим, все члены класса Student определены в пространстве имен Student.

Среди методов выделяют несколько особых групп. Среди них: *конструкторы*, *деструкторы*, *сеттеры* и *геттеры*.

### Конструкторы

Конструктор — это особая функция, которая является членом класса и вызывается при создании нового объекта. В языке C++ название конструктора всегда совпадает с именем класса, таким образом, вернувшись к примеру со студентом, мы получим:

```C++
class Student {
	private:
		char name[32];
		char surname[32];
		unsigned short course;
		float avg_grade;
	public:
		Student(); // конструктор
		void say_name();
		float get_avg_grade();
} ;
```

Конструкторы можно передавать параметры, более того, можно объявить несколько конструкторов. В таком случае, поведение программы определяется, как и в случае с перегрузкой любых других функций: будет выбрана функция с наиболее подходящим прототипом. Конструкторы используются для инициализации нового объекта, присвоения его членам данных начальных значений.

### Деструкторы

Деструктор — это злой брат-близнец конструктора. Деструктор будет вызван в случае удаления объекта. Эти функции используются для очистки памяти и подобных задач. Деструктор определяется при помощи конструкции ~*Имя_Класса*:

```C++
class Student {
	private:
		char name[32];
		char surname[32];
		unsigned short course;
		float avg_grade;
	public:
		Student(); // конструктор
		~Student(); // а это деструктор
		void say_name();
		float get_avg_grade();
} ;
```

Деструктор не принимает не каких параметров, следовательно для каждого класса существует единственная возможная сигнатура деструктора и воспользоваться перегрузкой в отношении деструкторов не получится.

### Сеттеры и геттеры

Сеттеры и геттеры не являются специальными методами с точки зрения синтаксиса, но значительно выделяются с точки зрения семантики. Они предназанчены для предоставления контролируемого доступа к закрытым членнам данных. Т.е. если мы говорим, что имя студента это массив 32 символов, но при этом хотим, чтобы программа выдавала ошибку, при задании имени, содержащего, скажем, цифры, то нам необходимо объявить имя как закрытый член данных, а доступ к нему осуществлять через сеттер. Соответственно, для получения значения закрытого члена данных используется геттер.

## Основные принципы ООП

Основные принципы ООП включают в себя *инкапсуляцию*, *полиморфизм* и *наследование*.

### Инкапсуляция

Принцип инкапсуляции гарантирует нам, что члены данных одного объекта существуют в независимости от другого. Например:

```C++
class CookieJar {
	private:
		unsigned long long cookiescount;
	public:
		CookieJar(unsigned long long);
		~CookieJar();
		void setcookiescount(unsigned long long);
		unsigned long lon getcookiescount();

CookieJar::CookieJar(unsigned long long cookiescount) {
	this.cookiescount = cookiescount;
}

CookieJar::~CookieJar() {
	if (cookiescount > 1)
		std::cout << "Oh no! " << cookiescount << " cookies got destroyed!\n";
	else if (cookiescount)
		std::cout << "Sadly, we lost a cookie.\n";
	else
		std::cout << "Destroyed a jar without any cookies in it.\n"
}

void CookieJar::setcookiescount(unsigned long long cookiescount) {
	this.cookiescount = cookiescount;
}

unsigned long long CookieJar::getcookiescount() {
	return cookiescount;
}

void main() {
	CookieJar Jar1(3), Jar2(3);

	Jar1.setcookiescount(1);
	std::cout << Jar2.getcookiescount(); // выведет 3
}
```

### Наследование

Наследование — механизм, позволяющий встраивать объявление одного класса в другой. При этом встраиваемый класс называется *предком*, а класс, в который выполняется встраивание, — *наследником*. В C++ для использования наследования необходимо указать имя класса-предка во время объявления:

```C++
class Cat {
	// ...
};

class MaineCoon : Cat {
	// ...
};
```

При необходимости можно указать параметр *доступ* при наследовании:

```C++
class Cat {
	// ...
};

class MaineCoon : private Cat {
	// ...
};

class Siamese : protected Cat {
	// ...
};

class ScottishFold : public Cat {
	// ...
};
```

Как видно, доступ определяется одним из уже знакомых нам ключевых слов: *private*, *protected* и *public*. При этом доступ определяет, каким образом будут доступны члены класса-предка:

| Член предка | Private | Protected | Public    |
| Private     | X       | X         | X         |
| Protected   | Private | Protected | Protected |
| Public      | Private | Protected | Public    |

Возможно наследование нескольких классов, тогда классы-предки перечисляются через запятую, каждый со своим типом доступа:

```C++
class Lycanthrope: public Human, protected Wolf {
	// ...
};
```

При вызове конструктора потомка, сначала будет вызван конструктор предка. При вызове деструктора потомка, сначала выполнится он, а затем уже деструктор предка. Для передачи параметров конструктору класса-предка в конструкторе класса потомка используется следующий прием:

```C++
class Lycanthrope: public Human, protected Wolf {
	public:
		Licantrhrope(hair_color, wool_color): Human(hair_color), Wolf(wool_color) {
			// ...
		};
	// ...
};
```

### Полиморфизм

Разделяют два типа полиморфизма: статический и динамический. К статическому полиморфизму относятся перегрузка функций (о ней ниже) и перегрузка операторов (о ней в следующей лекции). Динамический полиморфизм в C++ представлен в двух вариантах: полиморфизм указателей на класс и полиморфизм методов (речь идет о т.н. *виртуальных* функциях).

### Указатели на производные классы

Любой указатель на объект какого-либо класса может также указывать и на объект класса-потомка. Возвращаясь к примеру с кошками:

```C++
Cat *p;
Cat C;
Siamese S;

p = &C; // указывает на объект класса Cat
p = &S; // указывает на объект класса Siamese
```

При этом стоит отметить, что будут доступны только члены базового класса, для доступа к членам класса-наследника нужно воспользоваться явным приведением типа указателя. Также нельзя забывать, что обратный прием, т.е. доступ к классу-предку через указатель на класс-наследник, не является корректным.

### Виртуальные функции

Виртуальные функции — функции, которые определены в базовом классе, но в последствии могут быть переопределены в классах-потомках. Для объявления виртуального метода используется ключевое слово *virtual*. При этом "виртуальность" наследуется, т.е. для виртуального метода достаточно указать только в базовом классе слово virtual и все определения этого метода в классах-наследниках независимо от глубины вложенности наследования будут являться виртуальными.

```C++
class Dog {
	public:
		void speak() {
			std::cout << "Woof!\n";
		}
}

class Bassenji : public Dog {
	public:
		void speak() {
			std::cout << "Yodel!\n";
		}
}
```

При обращении к виртуальному методу поведение определяется ближайшим в иерархии определением. Т.е. если метод определен в классе объекта — будет вызван он, если нет — метод класса-предка. Если нет в классе-предке, то будет вызван метод предка по отношению к классу-предку и т.д.

Виртуальные функции используются для поддержания принципа "один интерфейс, множество методов". Т.е. когда мы предоставляем один и тот же интерфейс к разному с точки зрения логики интерфейсу. В примере с собаками, разные породы собак будут по разному реагировать на команду "Голос!", но при этом интерфейс этого взаимодействия один и тот же. Также можно рассмотреть, скажем руление на объектах типа "скейтборд", "велосипед", "автомобиль", "самолет". Будем считать, что для всех них введен базовый класс "транспорт". Тогда введя виртуальную функцию void steer(degree) для базового класса и определив ее поведение для всех классов-потомков, мы как раз обеспечим один общий интерфейс, который позволяет нам изменить курс нашего транспортного средства на указанное число градусов, при этом не обращая внимания на то, что внутренния логика руления скейтбордом и самолетом, мягко говоря, различная.

Если после объявления виртуальной функции мы указываем = 0, то такая функция называется *чисто виртуальной*. Она не реализована в базовом классе, но должна быть реализована в классе-потомке. Класс, содержащий хотя бы одну чисто виртуальную функцию называется *абстрактным*. Абстрактный класс не может иметь объектов, но при этом нет ограничения на создание ссылок и указателей на абстрактные классы.

## Перегрузка функций

В C++ возможно перегружать функции, т.е. определять различные функции с одним и тем же именем, если количество и/или типы параметров у них отличаются. Таким образом, мы можем определить, скажем две фукнции add, поведение которых будет отличаться в зависимости от того, переданы ей числа или вектора:

```C++
typedef struct custom_vector {
	int *values;
	unsigned length;
} custom_vector;

int add(int, int);
custom_vector add(custom_vector, custom_vector);

// ...

int add(int a, int b) {
	return a + b;
}

custom_vector add(custom_vector a, custom_vector b) {
	custom_vector res;

	res.length = 0;
	res.values = NULL;

	if (a.length != b.length) return res;

	res.values = (int *) calloc(a.length, sizeof(int));
	if (res.values == NULL) return res;
	for(int i; i<a.length; i++) {
		res.values[i] = a.values[i] + b.values[i];
	}
	res.length = a.length;
	return res;
}
```

## Передача аргументов по ссылке

В C++ есть возможность объявлять ссылочные параметры в функциях:

```C++
void swap(int &x, int &y) {
	int temp;
	temp = x;
	x = y;
	y = temp;
}
```

Когда мы вызовем данную функцию `swap (a, b)`, то будут автоматически взяты адреса a и b, разыменованы и полученные значения присвоены x и y. Т.е., если проводить параллели с указателями, x и y будут соответствовать \*a и \*b.

## Аргументы по умолчанию

В C++ есть возможность объявлять функции с аргументами, со значением по умолчанию:

```C++
double log(double x, double base=E);

// ...

log(5); // аналогично log(5, E)
log(10, 2);

// ...
```

Данная возможность позволяет определять функции с большим количеством параметров, чем это необходимо в наиболее распространненых случаях. Таким образом, мы задаем некоторое поведение по умолчанию, но позволяем пользователю его модифицировать.

## Дополнительно: передача аргументов функции main

В C++ для функции main определены два аргумента: argc и argv. Это аргументы, которые передаются от командной строки. Конечно, вы можете выбрать для них любое имя, но традиционно это argc — количество аргументов и argv — список аргументов:

```C++
int main(int argc, char *argv[]) {
	// ...
}
```

Соответственно, когда вы будете обращаться к вашей программа через командную оболочку `echo hello world`, где `echo` — имя программы, а `hello` и `world` — ее параметры (на самом деле первым параметром, передаваемым программе будет как раз имя программы, с которым оно было вызвано, что может быть полезно для вывода справки об использовании программы), программа сможет модифицировать свое поведение в зависимости от того, какие параметры ей были переданы.

## Домашнее задание

1-й раздел из файла assignments.pdf
Читать Герберт Шилдт "C++ базовый курс", главы 1-15.